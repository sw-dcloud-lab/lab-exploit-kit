#!/bin/bash
#------------------------------------------------------------------------------#
# Copyright (C) 2018 Cisco
# Proprietary and Confidential
#
# Stealthwatch Test Drive script used to load processes and functions to
# simulate an exploit kit during a real attack
# 06/15/18 - version 1.3
#------------------------------------------------------------------------------#

# 1) put encrpted-customer-DB into place for Insider Threat and Advanced Threat labs
#     copy a large file to /root/encrypted-customer-DB for the Data Hoarding use case test drive lab
#     used to show a large east west data transfer and the file will be used in the Data Exfiltration lab
cp /lancope/var/tcpdump/daily/FLOW-REPLAY-0705.pcap /root/encrypted-customer-DB

USRCIS="/usr/local/cisco/"
CISHGA="/usr/local/cisco/hga/"
VARCIS="/var/cisco/"
COMDAT="/var/cisco/component-databases/"
LOGCIS="/var/log/cisco/"
LOGHGA="/var/log/cisco/hga/"
LVARPS="/lancope/var/ps/"
OPTCIS="/opt/cisco/"
KEYREG="/opt/cisco/keystore-registry/"

# 2) create needed directories, set owner/group
mkdir $USRCIS; chown tomcat $USRCIS; chgrp tomcat $USRCIS
mkdir $CISHGA; chgrp tomcat $USRCIS # this is correct, we want root to still own it
mkdir $VARCIS; chown tomcat $VARCIS; chgrp tomcat $VARCIS
mkdir $COMDAT; chown tomcat $COMDAT; chgrp tomcat $COMDAT
mkdir $LOGCIS
mkdir $LOGHGA
mkdir $LVARPS
mkdir $OPTCIS
mkdir $KEYREG

# 3) untar files to directory and set group
tar -xf /root/install-exploit-kit.tar -C /usr/local/cisco/hga/
chgrp -R tomcat /usr/local/cisco/hga/*
chmod -R 777 /usr/local/cisco/

# 4) move the C1sco12345 password file into place, vs. running ./cisco_set_account.sh hga/admin
mv "$CISHGA".passwd "$KEYREG".passwd

# 5) obtain the unique serial # and then register it
JAVSER=`/usr/bin/java -Dtracelevel=debug -cp /usr/local/cisco/hga/lib/pss-1.1.0.jar com.lancope.ps.apiext.support.License getsn`
# echo ""; echo -e "Java Serial: $JAVSER"; echo ""
java -cp "$CISHGA/lib/pss-1.1.0.jar:./commons-codec-1.8.jar" com.lancope.ps.apiext.support.License setlicense hga "Permanent|$JAVSER|Cisco|beclay@cisco.com|2099-01-01T01:00:00Z|all"

# 6) associate (and immediately run) the chuck-yeager user for the workstation (wkst1) on IP: 198.18.133.36
# logins
USRSRC="/lancope/var/ise/scripts/sources/AlwaysOn-login.txt"
WKST1=`cat /lancope/var/ise/scripts/sources/AlwaysOn-login.txt | grep 198.18.133.36`
if [ "$WKST1" = "" ]; then
 echo "curl -X PUT 'http://127.0.0.1:4567/generateSession?isMachineAuth=false&ipAddress=198.18.133.36&gid=1111977222&userName=chuck-yeager'" >> $USRSRC
 curl -X PUT 'http://127.0.0.1:4567/generateSession?isMachineAuth=false&ipAddress=198.18.133.36&gid=1111977222&userName=chuck-yeager' > /dev/null 2>&1
fi
# logouts
USRSRC="/lancope/var/ise/scripts/sources/AlwaysOn-logout.txt"
WKST1=`cat /lancope/var/ise/scripts/sources/AlwaysOn-logout.txt | grep 198.18.133.36`
if [ "$WKST1" = "" ]; then
 echo "curl -X PUT 'http://127.0.0.1:4567/generateSession?isMachineAuth=true&ipAddress=198.18.133.36&gid=1111977222&userName=chuck-yeager'" >> $USRSRC
fi

# 7) add aliases to the /root/.alias file
ALIASFILE="/root/.bash_aliases"
# hostgroupautomation (or) hga alias
ALIASHGA=`cat "$ALIASFILE" | grep hga`
if [ "$ALIASHGA" = "" ]; then
 echo "alias hga='/usr/local/cisco/hga/bin/process_ipam.sh'" >> $ALIASFILE
 echo "alias hostgroupautomation='/usr/local/cisco/hga/bin/process_ipam.sh'" >> $ALIASFILE
fi
# customthreatfeed (or) ctf alias
ALIASCTF=`cat "$ALIASFILE" | grep ctf`
if [ "$ALIASCTF" = "" ]; then
 echo "alias ctf='/usr/local/cisco/hga/bin/process_threatfeed.sh'" >> $ALIASFILE
 echo "alias customthreatfeed='/usr/local/cisco/hga/bin/process_threatfeed.sh'" >> $ALIASFILE
fi

# logged results of HGA scripts are found in...
# cat /var/log/cisco/hga/process_groups.log
# ...and...
# cat /var/log/cisco/hga/ipam_outside.<DATE>.<TIMESTAMP>.log

# clean up any extra windows characters that might have copied over
# sed -i -e 's/\r$//' /lancope/var/pov-scripts/assessment.sh

echo ""; echo "Install complete."; echo ""

# reloading bash to pick up the new aliases (not a big deal, but requires typing 'exit' twice to close out of the shell)
exec bash

# EOF
